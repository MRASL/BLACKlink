/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue Aug 26 15:00:56 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

typedef enum 
{
    Debug_None,
	Debug_Level_0, // Basic Debug Info Output
    Debug_Level_1, // + Critical Info Only
	Debug_Level_2, // + Diagnostics Info
	Debug_Level_3, // + Program Flow Info
	Debug_Level_4, // + Registry Data
	Debug_Level_5  // + TBD 
}eDebugLevel;


// Initialize Error
// eError_No iError_No = Error_None;

// Define Error Severity Levels
typedef enum
{
    Error_Level_OK=0,
    Error_Level_Critical, // (Stop Simulation)
    Error_Level_Warning
}eError_Level;
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void BBB_Quaternion_Euler_Conversion_Outputs_wrapper(const real_T *inQuat_q_1,
                          const real_T *inQuat_q_2,
                          const real_T *inQuat_q_3,
                          const real_T *inQuat_q_4,
                          real_T *outYaw_psi,
                          real_T *outPitch_theta,
                          real_T *outRoll_phi ,
			      const real_T  *xD,
                          const uint8_T  *prmAngle_Output_Deg_Rad, const int_T p_width0)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
#ifndef MATLAB_MEX_FILE

// Declare Temp Input Holder Variables
double dQuat_q_1=0.0f;
double dQuat_q_2=0.0f;
double dQuat_q_3=0.0f;
double dQuat_q_4=0.0f;

// Declare Temp Output Holder Variables
double dAngle_Yaw=0.0f;
double dAngle_Pitch=0.0f;
double dAngle_Roll=0.0f;

#define dPi 3.1415926535

// Define Error Number
typedef enum 
{
    Error_None=0,
    Error_No_SYSFSOpen,
    Error_No_SYSFSRead,
    Error_No_SYSFSWrite,
    Error_No_ParamOutofRange
}eError_No;

// Initialize Error
eError_No iError_No = Error_None;

// Initialize Debug Level
eDebugLevel iDebug_Level = Debug_Level_5;

// Read Input Data
dQuat_q_1=inQuat_q_1[0];
dQuat_q_2=inQuat_q_2[0];
dQuat_q_3=inQuat_q_3[0];
dQuat_q_4=inQuat_q_4[0];

// Calculate Euler Angles From Quaternions (from IEEE Paper)
/*
dAngle_Yaw=atan2(2.0f*dQuat_q_2*dQuat_q_3-2.0f*dQuat_q_1*dQuat_q_4,
                 2.0f*dQuat_q_1*dQuat_q_1+2.0f*dQuat_q_2*dQuat_q_2-1.0f);

dAngle_Pitch=-1*asin(2.0f*dQuat_q_2*dQuat_q_4+2.0f*dQuat_q_1*dQuat_q_3);

dAngle_Roll=atan2(2.0f*dQuat_q_3*dQuat_q_4-2.0f*dQuat_q_1*dQuat_q_2,
                  2.0f*dQuat_q_1*dQuat_q_1+2.0f*dQuat_q_4*dQuat_q_4-1.0f);
*/
// Calculate Euler Angles From Quaternions (from Quat to Euler Wiki)
dAngle_Yaw=atan2(2.0f*(dQuat_q_1*dQuat_q_4+dQuat_q_2*dQuat_q_3),
                 1.0f-2.0f*(dQuat_q_3*dQuat_q_3+dQuat_q_4*dQuat_q_4));

dAngle_Pitch=asin(2.0f*(dQuat_q_1*dQuat_q_3-dQuat_q_4*dQuat_q_2));

dAngle_Roll=atan2(2.0f*(dQuat_q_1*dQuat_q_2+dQuat_q_3*dQuat_q_4),
                  1.0f-2.0f*(dQuat_q_2*dQuat_q_2+dQuat_q_3*dQuat_q_3));


// Output Data
if (prmAngle_Output_Deg_Rad[0]==1)
{
    // Output Angle Data in Radians
    outYaw_psi[0]=dAngle_Yaw;
    outPitch_theta[0]=dAngle_Pitch;
    outRoll_phi[0]=dAngle_Roll;
    // Output Quaternion Data
    if (iDebug_Level >=Debug_Level_1) { printf("Euler Angle Data (Radians)> Yaw: %.2f Pitch: %.2f Roll: %.2f \n",outYaw_psi[0],outPitch_theta[0],outRoll_phi[0]);}

}
else
{
    // Output Angle Data in Degrees
    outYaw_psi[0]=dAngle_Yaw*(180.0/dPi);
    outPitch_theta[0]=dAngle_Pitch*(180.0/dPi);
    outRoll_phi[0]=dAngle_Roll*(180.0/dPi);
    // Output Quaternion Data
    if (iDebug_Level >=Debug_Level_1) { printf("Euler Angle Data (Degrees)> Yaw: %.2f Pitch: %.2f Roll: %.2f \n",outYaw_psi[0],outPitch_theta[0],outRoll_phi[0]);}

}

// Output Quaternion Data
// if (iDebug_Level >=Debug_Level_1) { printf("Euler Angle Data> Yaw: %.2f Pitch: %.2f Roll: %.2f \n",outYaw_psi[0],outPitch_theta[0],outRoll_phi[0]);}
 

#endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}

/*
  * Updates function
  *
  */
void BBB_Quaternion_Euler_Conversion_Update_wrapper(const real_T *inQuat_q_1,
                          const real_T *inQuat_q_2,
                          const real_T *inQuat_q_3,
                          const real_T *inQuat_q_4,
                          const real_T *outYaw_psi,
                          const real_T *outPitch_theta,
                          const real_T *outRoll_phi ,
                           real_T *xD, 
                          const uint8_T  *prmAngle_Output_Deg_Rad, const int_T  p_width0)
{
  /* %%%-SFUNWIZ_wrapper_Update_Changes_BEGIN --- EDIT HERE TO _END */
 
/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
}
