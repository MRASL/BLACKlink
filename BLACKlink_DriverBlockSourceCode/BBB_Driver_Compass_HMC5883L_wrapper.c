/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Sun Dec 14 05:08:04 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>



# ifndef MATLAB_MEX_FILE

	#include <linux/i2c.h>
	#include <linux/i2c-dev.h>
	#include <sys/ioctl.h>
	#include <unistd.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>

# else

	#include <mex.h>
	#include <simstruc.h>

# endif

// Define Compass I2C Address
# define cCompass_I2C_Addr1 0x1E

// Define Read/Write Command Reg
# define cCompass_I2C_Read 0x3D
# define cCompass_I2C_Write 0x3C

// Define Register Read Size
# define cCompass_I2C_BufferSize 0x0D

// Define Register Read Start Position
# define cCompass_I2C_StartPosReg 0x09
// Note that start position must be set to 0x09 instead of 0x00 as compas
// module automatically resets read pointer to start of data block registers
// "The HMC5883L will automatically re-point back to register 3 for the next 0x3D query"

// Define Compass ID (For Data Validation / CheckSum)
# define cCompass_IDA_Value 0x48   
# define cCompass_IDB_Value 0x34
# define cCompass_IDC_Value 0x33

// Define Conversion Constant Gauss to MicroTesla
# define iCompass_Gauss_uTesla_Conv 100

// Define Compass Self Test Settings
# define cCompass_SelfTest_ConfigAReg 0x71 // 8-average 15 Hz, Positive
# define cCompass_SelfTest_Exit 0x70 // Exit Self Test
# define cCompass_SelfTest_LimMax 575 // Max Limit for Gain = 5
# define cCompass_SelfTest_LimMin 243 // Min Limit for Gain = 5

// Define Compass Registry Locations
typedef enum
{
    cCompass_ConfigAReg     =0x00,
    cCompass_ConfigBReg     =0x01,
    cCompass_ModeReg        =0x02,
    cMagField_X_MSBReg      =0x03,
    cMagField_X_LSBReg      =0x04,
    cMagField_Z_MSBReg      =0x05,
    cMagField_Z_LSBReg      =0x06,
    cMagField_Y_MSBReg      =0x07,
    cMagField_Y_LSBReg      =0x08,
    cCompass_StatusReg      =0x09,
    cCompass_IDAReg         =0x0A,
    cCompass_IDBReg         =0x0B,
    cCompass_IDCReg         =0x0C
} eCompass_RegVal;

// Define Compass Mode Settings
typedef enum 
{
    cCompass_Mode_ContMeasure   =0x00,
    cCompass_Mode_SingleMeasure =0x01,
    cCompass_Mode_Idle          =0x02
} eCompass_ModeSet;

// Define Compass Gain Settings
typedef enum
{
    cCompass_Gain_1370  =0x00,
    cCompass_Gain_1090  =0x20,
    cCompass_Gain_820   =0x40,  
    cCompass_Gain_660   =0x60,
    cCompass_Gain_440   =0x80,
    cCompass_Gain_390   =0xA0,
    cCompass_Gain_330   =0xC0,
    cCompass_Gain_230   =0xE0
} eCompass_GainSet;

// Define Compass Number of Samples for Averaged Output
typedef enum
{
    cCompass_AvrgSamples_1  =0x00,
    cCompass_AvrgSamples_2  =0x20,
    cCompass_AvrgSamples_4  =0x40,
    cCompass_AvrgSamples_8  =0x60
} eCompass_AvrgSampleSet;

// Define Compass Data Output Rate
typedef enum
{
    cCompass_DataOutRate_075    =0x00,
    cCompass_DataOutRate_150    =0x04,
    cCompass_DataOutRate_300    =0x08,
    cCompass_DataOutRate_750    =0x0C,
    cCompass_DataOutRate_1500   =0x10,
    cCompass_DataOutRate_3000   =0x14,
    cCompass_DataOutRate_7500   =0x18,
    cCompass_DataOutRate_Rsv    =0x1C
} eCompass_DataOutRateSet;

// Define Compass Measurement Mode
typedef enum
{
    cCompass_ModeMeas_Normal    =0x00,
    cCompass_ModeMeas_PosBias   =0x01,
    cCompass_ModeMeas_NegBias   =0x02,
    cCompass_ModeMeas_Rsv       =0x03
} eCompass_MeasModeSet; 

// Function Options (1=On/0=Off)
// int iOpt_TwoComplement = 1; // Data To Be Treated as Two's Complement

// Delcare Global Variables
// int iLoop_Counter_DS=0;
int iLoop_DataNotReady_Counter=0;

// Define Debug Levels
typedef enum 
{
    Debug_None,
	Debug_Level_0, // Basic Debug Info Output
    Debug_Level_1, // + Critical Info Only
	Debug_Level_2, // + Diagnostics Info
	Debug_Level_3, // + Program Flow Info
	Debug_Level_4, // + Registry Data
	Debug_Level_5  // + TBD 
}eDebugLevel;

// Initialize Debug Output Level
// eDebugLevel iDebug_Level = Debug_None;

// Define Error Number
typedef enum 
{
    Error_None=0,
    Error_No_I2CComm,
    Error_No_I2CInit,
    Error_No_I2CBuffSet,
    Error_No_I2CBuffRead,
    Error_No_I2CBuffSync,
    Error_No_I2CBuffWrite,
    Error_No_ParamOutofRange,
    // Define Compass Specific Error Numbers       
    Error_Compass_No_SelfTest = 11        
}eError_No;

// Define Error Severity Levels
typedef enum
{
    Error_Level_OK=0,
    Error_Level_Critical, // (Stop Simulation)
    Error_Level_Warning
}eError_Level;

// Initialize Error Level
// eError_Level iError_Level = Error_Level_OK;

// Define Parameter Selection: Compass Sensitivity
typedef enum 
{
    iAngVel_250dps=1,
    iAngVel_500dps=2,
    iAngVel_2000dps=3
}eGyro_Range;
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void BBB_Driver_Compass_HMC5883L_Outputs_wrapper(real_T *outMagField_HX,
                          real_T *outMagField_HY,
                          real_T *outMagField_HZ,
                          real_T *outMagField_HE,
                          real_T *outMagField_Heading,
                          real_T *outSimStop ,
			      const real_T  *xD,
                          const uint8_T  *prmI2C_DeviceNo, const int_T  p_width0, 
                          const uint8_T  *prmI2C_BusNo, const int_T  p_width1, 
                          const uint8_T  *prmCompass_DataOutAvrg, const int_T  p_width2, 
                          const uint8_T  *prmCompass_DataOutRate, const int_T  p_width3, 
                          const uint8_T  *prmCompass_MeasureMode, const int_T  p_width4, 
                          const uint8_T  *prmCompass_GainValue, const int_T  p_width5, 
                          const uint8_T  *prmCompass_OpMode, const int_T  p_width6, 
                          const uint8_T  *prmCompass_HeadingMode, const int_T  p_width7, 
                          const real_T  *prmCompass_HeadingOffset, const int_T  p_width8, 
                          const real_T  *prmCompass_DeclinationAng, const int_T  p_width9, 
                          const boolean_T  *prmCompass_SelfTest, const int_T  p_width10, 
                          const uint8_T  *prmCompass_SelfTest_GainValue, const int_T  p_width11, 
                          const uint8_T  *prmDebug_InfoLevel, const int_T p_width12)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
// Run Only on Target - BeagleBoneBlack */
# ifndef MATLAB_MEX_FILE

// Define File Sys Pointer - For I2C Bus#1 -> Make Parameter
int iFILE_BBB_I2C_Handle=0;
int iIOCTL_BBB_I2C_Handle=0;
int iSYNC_BBB_I2C_Handle=0;
int iWRITE_BBB_I2C_Handle=0;
// Function Outputs
int iI2C_Read=0;
int iI2C_Write=0;

//Define Device Driver sysfs Location 
char sBBB_I2C_BUS1_FILE[100]="";

// Define Internal Variables Data
int iCompass_MagField_X=0;
int iCompass_MagField_Y=0;
int iCompass_MagField_Z=0;
int iCompass_MagField_Temp=0;

// Declare Temporary Variables For Bit Manipulation
double dCompass_MagField_Temp=0.0f;

// Declare Variables For Device Registry Read/Write
unsigned char cI2C_StatReg_Temp=0;
 
// Define I2C Parameters
int iI2C_BytesRead=0;
// Define I2C Buffer Size
const int iI2C_BufferSize=(int)cCompass_I2C_BufferSize;
// Define I2C Buffer Dump Variable
char cI2C_Buffer[cCompass_I2C_BufferSize]={0x00}; //unsigned cCompass_I2C_BufferSize
// Define I2C Temp Buffer Dump Variable
char cI2C_Buffer_Temp[cCompass_I2C_BufferSize]={0x00};
// Define I2C Buffer Dump Start Position. 
char cI2C_Buffer_Sync[1]={cCompass_I2C_StartPosReg}; // Start at reg 0x00 cCompass_I2C_StartPosReg
// Define I2C Read Buffer Size
char cI2C_Buffer_Read[1]={cCompass_I2C_BufferSize};
// Define I2C Buffer Offser For Remapping
char cI2C_Buffer_Offset=(cCompass_I2C_BufferSize - cCompass_I2C_StartPosReg);
// Define Write Buffer
char cI2C_Buffer_Write[2]={0x00};
// Define I2C Buffer Status 
char cI2C_Buffer_Status=0;//unsigned
// Define I2C Status Bits: 
int iI2C_STATUS_REG_DATARDY=0;  // Bit 0 - X,Y or Z Data Overwritten 
int iI2C_STATUS_REG_DATALOCK=0;  // Bit 1 - X,Y or Z New Data Available
// Define Loop Counters
int iLoop=0;
int iLoop_Counter;
// Define Device Address
char cCompass_I2C_Addr_Para=0x00;
char cCompass_I2C_Addr=0X00;
// Define Operation Mode Parameter Placeholder
char cCompass_OpMode=0x00;
// Define Measurement Mode Parameter Placeholder
char cCompass_MeasureMode=0x00;
// Define Out Average Data Parameter Placeholder
char cCompass_DataOutAvrg=0x00;
// Define Data Out Rate Parameter Placeholder
char cCompass_DataOutRate=0x00;
// Define Gain Value Parameter Placeholder
char cCompass_GainValue=0x00;
// Define Temp Register Storage Variables
char cCompass_ConfigRegA_Val=0x00;
char cCompass_ConfigRegB_Val=0x00;

// Initialize Error
eError_No iError_No = Error_None;

// Initialize Error Level
eError_Level iError_Level = Error_Level_OK;

// Initialize Debug Output Level - From Parameter Selection
eDebugLevel iDebug_Level = Debug_Level_1;

// Function Options (1=On/0=Off)
int iOpt_TwoComplement = 1; // Data To Be Treated as Two's Complement

// *************************************//
// Define Function iCompass_I2CReadBuff
// *************************************//
int iCompass_I2CReadBuff()
{
    
    // Create Handle to SYSFS File Stream
    sprintf(sBBB_I2C_BUS1_FILE,"/dev/i2c-%u",prmI2C_BusNo[0]);
    
    // Check I2C Bus Concatenation
    if (iDebug_Level >=Debug_Level_2)  { printf("Compass Msg: I2C Bus File Location: %s\n",sBBB_I2C_BUS1_FILE); }
        
    // Open Data IO Stream
    iFILE_BBB_I2C_Handle = open(sBBB_I2C_BUS1_FILE, O_RDWR);
    
    // Confirm I2C Bus Open
    if (iFILE_BBB_I2C_Handle<0)
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1)  { printf("Compass Error: Failed to Open I2C Bus - Check Device/Device Tree\n"); }
        // Set Error Number
        iError_No = Error_No_I2CComm;
        // Set Error Level
        iError_Level = Error_Level_Critical;
        // Return Otuput Error Level
        // return -1;
    }
    
    // Ouput Program Flow
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 2: Connect To I2C Bus\nError No: %i Error Level: %i\n",iError_No, iError_Level);}
   
    // Initiate I2C Communicaton
    if (iError_No == Error_None)
    {
        // Initiate Communicaiton
        iIOCTL_BBB_I2C_Handle=ioctl(iFILE_BBB_I2C_Handle,I2C_SLAVE,cCompass_I2C_Addr);
        
        // Error Handling
        if (iIOCTL_BBB_I2C_Handle<0)
        {
            if (iDebug_Level >=Debug_Level_1) {printf("Compass Error: Failed to Communicate With Slave Device\n");}
            // Set Error Number
            iError_No = Error_No_I2CInit;
            // Set Error Level
            iError_Level = Error_Level_Critical;
            // Return Otuput Error Level
            // return -1;            
        }
    }
    
   // Ouput Program Flow
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 3: Connect to I2C Device\nError No: %i Error Level: %i\n",iError_No, iError_Level);}

    // Set Buffer Start Position
    if (iError_No == Error_None)
    {
        iWRITE_BBB_I2C_Handle = write(iFILE_BBB_I2C_Handle, cI2C_Buffer_Sync,sizeof(cI2C_Buffer_Sync));
        // Error Handling
        if (iWRITE_BBB_I2C_Handle!=sizeof(cI2C_Buffer_Sync))
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1) { printf("Compass Error: Failed to Communicate With Device and/or Set Buffer Read Range\n");}
            // Set Error Number
            iError_No = Error_No_I2CBuffSet;
            // Set Error Level
            iError_Level = Error_Level_Critical;
            // Return Otuput Error Level
            // return -1;
        }
        else
        {
            if (iDebug_Level >=Debug_Level_1) { printf("Compass Msg: Register Read Start Position Set\n");}
        }
    }
       
    // Ouput Program Flow
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 4: Write Registry Read Start Position Set\nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    
    // Read Buffer Data
    if (iError_No == Error_None)
    {
        // Read and Store Registry Data in Buffer
        iI2C_BytesRead = read(iFILE_BBB_I2C_Handle,cI2C_Buffer_Temp,sizeof(cI2C_Buffer_Temp)); // iI2C_BufferSize
        // Close File
        close(iFILE_BBB_I2C_Handle); 
        
        // Error Handling - Confirm Buffer Size
        if (iI2C_BytesRead<0)
        {
            // Error on Buffer Read!
            if (iDebug_Level >=Debug_Level_1) { printf("Compass Error: Failed to Read Device Register. Bytes Read: %i\n",iI2C_BytesRead );}
            // Set Error Number
            iError_No = Error_No_I2CBuffRead;
            // Set Error Level
            iError_Level = Error_Level_Critical;
            // Return Otuput Error Level
            // return -1;
        }
        else
        {
            // Registry Data Read!
            if (iDebug_Level >=Debug_Level_1) { printf("Compass Msg: Device Register Read. Bytes Read: %i\n",iI2C_BytesRead );}
            
            // Print Registry Data
            if (iDebug_Level >=Debug_Level_4)
            {
                // Output Buffer Data
                for ( iLoop=0; iLoop<sizeof(cI2C_Buffer_Temp); iLoop++)
                {
                    printf("Compass Diagnostics: Temp Buffer Address %#04x = %#04x \n", iLoop, cI2C_Buffer_Temp[iLoop]);
                }
            }
            
            // Re-Map Buffer
            for ( iLoop=0; iLoop<(sizeof(cI2C_Buffer)-cI2C_Buffer_Offset); iLoop++)
            {
                cI2C_Buffer[iLoop]=cI2C_Buffer_Temp[iLoop+cI2C_Buffer_Offset];
            }
            for ( iLoop=(sizeof(cI2C_Buffer)-cI2C_Buffer_Offset); iLoop<sizeof(cI2C_Buffer); iLoop++)
            {
                cI2C_Buffer[iLoop]=cI2C_Buffer_Temp[iLoop-(sizeof(cI2C_Buffer)-cI2C_Buffer_Offset)];
            }      
            
            // Print Registry Data
            if (iDebug_Level >=Debug_Level_4)
            {
                // Output Buffer Data
                for ( iLoop=0; iLoop<sizeof(cI2C_Buffer); iLoop++)
                {
                    printf("Compass Diagnostics: Buffer Address %#04x = %#04x \n", iLoop, cI2C_Buffer[iLoop]);
                }
            }                      
            
            // Confirm Data Synced
            if ((cI2C_Buffer[cCompass_IDAReg]!=cCompass_IDA_Value)||(cI2C_Buffer[cCompass_IDBReg]!=cCompass_IDB_Value)||(cI2C_Buffer[cCompass_IDCReg]!=cCompass_IDC_Value)) 
            {
                // Error on Buffer Sync!
                if (iDebug_Level >=Debug_Level_1) { printf("Compass Error: Buffer Data Invalid! ID != 0x48,0x34,0x33 : %#04x,%#04x,%#04x\n",cI2C_Buffer[cCompass_IDAReg],cI2C_Buffer[cCompass_IDBReg],cI2C_Buffer[cCompass_IDCReg]);}
                // Set Error Number
                iError_No = Error_No_I2CBuffSync;
                // Set Error Level
                iError_Level = Error_Level_Critical;
                // Return Otuput Error Level
                // return -1;
            }
        }
    }    

    // Set Return State
    if (iError_No==0){return 0;} else {return -1;}

}

// *************************************//
// Define Function iCompass_I2CWriteBuff
// *************************************//
int iCompass_I2CWriteBuff(char cRegister_Address, char cRegister_Value)
{
   
    // Create Handle to SYSFS File Stream
    sprintf(sBBB_I2C_BUS1_FILE,"/dev/i2c-%u",prmI2C_BusNo[0]);
        
    // Check I2C Bus Concatenation
    if (iDebug_Level >=Debug_Level_2)  { printf("Compass Msg: I2C Bus File Location: %s\n",sBBB_I2C_BUS1_FILE); }
    
    // Open Data IO Stream
    iFILE_BBB_I2C_Handle = open(sBBB_I2C_BUS1_FILE, O_RDWR);
    
    // Confirm I2C Bus Open
    if (iFILE_BBB_I2C_Handle<0)
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1)  { printf("Compass Error: Failed to Open I2C Bus - Check Device/Device Tree\n"); }
        // Set Error Number
        iError_No = Error_No_I2CComm;
        // Set Error Level
        iError_Level = Error_Level_Critical;
        // Return Otuput Error Level
        // return -1;
    }
    
    // Ouput Program Flow
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: iCompass_I2CWriteBuff State 1: Connect To I2C Bus\nError No: %i Error Level: %i\n",iError_No, iError_Level);}

    
    // Initiate I2C Communicaton
    if (iError_No == Error_None)
    {
        // Initiate Communicaiton
        iIOCTL_BBB_I2C_Handle=ioctl(iFILE_BBB_I2C_Handle,I2C_SLAVE,cCompass_I2C_Addr);

        // Error Handling
        if (iIOCTL_BBB_I2C_Handle<0)
        {
            if (iDebug_Level >=Debug_Level_1) {printf("Compass Error: Failed to Communicate With Slave Device\n");}
            // Set Error Number
            iError_No = Error_No_I2CInit;
            // Set Error Level
            iError_Level = Error_Level_Critical;
            // Return Otuput Error Level
            // return -1;            
        }
    }

    // Ouput Program Flow
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: iCompass_I2CWriteBuff State 2: Connect to I2C Device\nError No: %i Error Level: %i\n",iError_No, iError_Level);}

    // Write Data to Register
    if (iError_No == Error_None)
    {
        // Set Compass To Register Address!
        // Set Compass Register Value
        cI2C_Buffer_Write[0]= cRegister_Address;    //cRegister_Address;
        cI2C_Buffer_Write[1]= cRegister_Value;  //cRegister_Value
        iWRITE_BBB_I2C_Handle = write(iFILE_BBB_I2C_Handle, cI2C_Buffer_Write, sizeof(cI2C_Buffer_Write));
        if (iDebug_Level >=Debug_Level_1) { printf("Compass Diag: Size of Write Data: %i Handle Output: %i\n",sizeof(cI2C_Buffer_Write),iWRITE_BBB_I2C_Handle);}
        
        if (iWRITE_BBB_I2C_Handle!=sizeof(cI2C_Buffer_Write))
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1) { printf("Compass Error: Failed to Communicate With Device and/or Write To Device Register\n");}
            // Set Error Number
            iError_No = Error_No_I2CBuffWrite;
            // Set Error Level
            iError_Level = Error_Level_Critical;
            // Return Otuput Error Level
            // return -1;
        }
        else
        {
            // Power Mode Set
            if (iDebug_Level >=Debug_Level_1){printf("Compass Msg: iCompass_I2CWriteBuff State 3: Data Written to Compass Register!\n");}
        }
    }
    // Close File
    close(iFILE_BBB_I2C_Handle);
    
    // Set Return State
    if (iError_No==0){return 0;} else {return -1;} 
}    

// *************************************//
// Define Function sCompass_ErrMessage
// *************************************//
const char *sCompass_ErrMessage(eError_No iCompass_ErrNo)
{
    //Set Error Message Based on Error Number
    switch(iCompass_ErrNo)
    {     
       case  Error_None:
            return("No Error Active. System A-OK!\n");
            break;
        case  Error_No_I2CComm: 
            return("Failed to Open I2C Bus\n - Check Bus Number\n - Check SCL/SCA Lines\n" 
                   " - Check Device\n - Check Device Tree on BBB\n");
            break;
        case Error_No_I2CInit:
            return("Failed to Communicate With Slave Device\n - Check Bus Number\n - Check SCL/SCA Lines\n" 
                   " - Check Device Address\n - Check Device Tree on BBB\n");        
            break;            
        case Error_No_I2CBuffSet:
            return("Failed to Set Buffer Read Range\n - Check Bus Number\n - Check SCL/SCA Lines\n" 
                   " - Check Device Address\n - Check Device Tree on BBB\n");            
            break;
        case Error_No_I2CBuffRead:
            return("Failed to Read Data in Registry Buffer\n - Check Bus Number\n - Check SCL/SCA Lines\n" 
                   " - Check Device Address\n - Check Device Tree on BBB\n");
            break;
        case Error_No_I2CBuffSync:
            return("Failed to Validate Registry Data - Inconsistent Data Stream\n"
                    " - Check For Multiple Master Access to Slave Device on I2C Bus Number\n"
                    " - Check SCL/SCA Lines\n - Check Device Address\n - Check Device Tree on BBB\n");
            break;            
        case Error_No_I2CBuffWrite:
            return("Failed to Write Data to Device Registry\n - Check Bus Traffic/Interference\n"
                   " - Check Bus Number\n - Check SCL/SCA Lines\n - Check Device Address\n - Check Device Tree on BBB\n"); 
            break;        
        case Error_No_ParamOutofRange:
            return("Parameter Out Of Range\n - Check Block Parameter Input Options\n");
            break;
        case Error_Compass_No_SelfTest:
            return("Compass Self Test Failed\n - Adjust Self Test Gain and Try Again\n");
            break;    
        default:
            // Error -Return Default 
            return("Error Code Not Recognized\n");
            break;
    }
}
 
// *************************************//
// Define Function iSet_Debug_Level
// *************************************//
int iSet_Debug_Level(eDebugLevel iDebug_Level_X)
{

    switch(iDebug_Level_X)
    {
        case  1:
            return (Debug_None);
            break;
        case  2:
            return (Debug_Level_0);
            break;
        case  3:
            return (Debug_Level_1);
            break;
        case  4:
            return (Debug_Level_2);
            break;
        case  5:
            return (Debug_Level_3);
            break;
        case  6:
            return (Debug_Level_4);
            break;
        case  7:
            return (Debug_Level_5);
            break;
        default:
            return (Debug_None);
            break;
    }
}
// *************************************//
// Define Function cCompass_SetGain
// *************************************//
char cCompass_SetGain(iprmCompass_GainValue)
{  
    // Read Selected Gain Data
    switch(iprmCompass_GainValue)
    {
        case  1:
            return(cCompass_Gain_1370);
            break;
        case  2:
            return(cCompass_Gain_1090);
            break;
        case  3:
            return(cCompass_Gain_820);
            break;
        case  4:
            return(cCompass_Gain_660);
            break;
        case  5:
            return(cCompass_Gain_440);
            break;
        case  6:
            return(cCompass_Gain_390);
            break;
        case  7:
            return(cCompass_Gain_330);
            break;
        case  8:
            return(cCompass_Gain_230);
            break;
        default:
            return(0x00);
            break;
    }
}
// *************************************//
// Define Function cCompass_SetDataOutRate
// *************************************//
char cCompass_SetDataOutRate(iprmCompass_DataOutRate)
{ 
    // Read Selected Data Output Rate
    switch(iprmCompass_DataOutRate)
    {
        case  1:
            return(cCompass_DataOutRate_075);
            break;
        case  2:
            return(cCompass_DataOutRate_150);
            break;
        case  3:
            return(cCompass_DataOutRate_300);
            break;
        case  4:
            return(cCompass_DataOutRate_750);
            break;
        case  5:
            return(cCompass_DataOutRate_1500);
            break;
        case  6:
            return(cCompass_DataOutRate_3000);
            break;
        case  7:
            return(cCompass_DataOutRate_7500);
            break;
        case  8:
            return(cCompass_DataOutRate_Rsv);
            break;
        default:
            return(0x00);
            break;
    }
}

// *************************************//
// Define Function cCompass_SetDataOutAvrg
// *************************************//
char cCompass_SetDataOutAvrg(iprmCompass_DataOutAvrg)
{ 
    // Read Selected Data Samples for Average Calculation of Output Data
    switch(iprmCompass_DataOutAvrg)
    {
        case  1:
            return(cCompass_AvrgSamples_1);
            break;
        case  2:
            return(cCompass_AvrgSamples_2);
            break;
        case  3:
            return(cCompass_AvrgSamples_4);
            break;
        case  4:
            return(cCompass_AvrgSamples_8);
            break;
        default:
            return(0x00);
            break;
    }
}
// *************************************//
// Define Function cCompass_SetMeasureMode
// *************************************//
char cCompass_SetMeasureMode(iprmCompass_MeasureMode)
{ 
    // Read Selected Compass Measurement Mode
    switch(iprmCompass_MeasureMode)
    {
        case  1:
            return(cCompass_ModeMeas_Normal);
            break;
        case  2:
            return(cCompass_ModeMeas_PosBias);
            break;
        case  3:
            return(cCompass_ModeMeas_NegBias);
            break;
        case  4:
            return(cCompass_ModeMeas_Rsv);
            break;
        default:
            return(0x00);
            break;
    }
}

// *************************************//
// Define Function cCompass_SetOpMode
// *************************************//
char cCompass_SetOpMode(iprmCompass_OpMode)
{
    // Read Selected Compass Mode Operation Mode
    switch(iprmCompass_OpMode)
    {
        case  1:
            return(cCompass_Mode_ContMeasure);
            break;
        case  2:
             return(cCompass_Mode_SingleMeasure);
            break;
        case  3:
             return(cCompass_Mode_Idle);
            break;
        default:
             return(0x00);
            break;
    }
}
// *************************************//
// Define Function cCompass_GetGainVal
// *************************************//
int cCompass_GetGainVal(eCompass_GainSet iCompass_GainSelect)
{  
    // Read Gain Setting And Return Corresponding Gain Conversion (LSb/Gauss)
    switch(iCompass_GainSelect)
    {
        case  cCompass_Gain_1370:
            return(1370);
            break;
        case  cCompass_Gain_1090:
            return(1090);
            break;
        case  cCompass_Gain_820:
            return(820);
            break;
        case  cCompass_Gain_660:
            return(660);
            break;
        case  cCompass_Gain_440:
            return(440);
            break;
        case  cCompass_Gain_390:
            return(390);
            break;
        case  cCompass_Gain_330:
            return(330);
            break;
        case  cCompass_Gain_230:
            return(230);
            break;
        default:
            return(0);
            break;
    }
}
// *************************************//
// Define Function vCompass_Initialize
// Description:
// Set Compass Parameters
// *************************************//
void vCompass_Initialize()
{       
    // Combine Bit Data For Registry A
    cCompass_ConfigRegA_Val = (cCompass_SetDataOutAvrg(prmCompass_DataOutAvrg[0]) | cCompass_SetDataOutRate(prmCompass_DataOutRate[0]) | cCompass_SetMeasureMode(prmCompass_MeasureMode[0]));
    // Verify Registry A Data
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Composite Registry A Data: %#04x\n",cCompass_ConfigRegA_Val);}
    // Set Compass Data Output Average, Data Output Rate and Compass Measurement Mode 
    iI2C_Write=iCompass_I2CWriteBuff(cCompass_ConfigAReg,cCompass_ConfigRegA_Val);
    // Check For Error
    if (iI2C_Write<0)
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1){printf("Compass Error: Failed to Set Device Output and Measurement Modes\n");}
    }
    else 
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1){printf("Compass Msg: Device Output and Measurement Modes Set\n");}
    }

    // Set Compass Gain Parameter For Registry B
    if (iError_No == Error_None)
    {
        // Write User Selected Gain To Compass
        iI2C_Write=iCompass_I2CWriteBuff(cCompass_ConfigBReg,cCompass_SetGain(prmCompass_GainValue[0]));
        // Check For Error
        if (iI2C_Write<0)
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Error: Failed to Set Device Gain Value Range\n");}
        }
        else
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Msg: Device Set to Requested Gain Value\n");}
        }   
    }
    
    // Set Compass Mode
    if (iError_No == Error_None)
    {           
        // Write User Selected Mode To Compass
        iI2C_Write=iCompass_I2CWriteBuff(cCompass_ModeReg,cCompass_SetOpMode(prmCompass_OpMode[0]));
        // Check For Error
        if (iI2C_Write<0)
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Error: Failed to Set Device Operation Mode \n");}
        }
        else
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Msg: Device Set to Requested Operation Mode \n");}
        } 
    }   
    
    // Output Info - Init Complete
    if (iError_No == Error_None)
    {
        // Ouput Program Flow
        if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 1A: Init Routine Complete\nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    }
    else
    {
        // Ouput Program Flow
        if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 1A: Init Routine Complete w/ Errors: \nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    } 
}

// *************************************//
// Define Function iCompass_TwoComplement
// *************************************//
short iCompass_TwoComplement(bOpt_TwoComplement,iTwoComplement_Int)
{
    // Declare Local Variable
    short _iTwoComplement_Temp=0;
    // Check For Two's Complement Option Activated
    if (bOpt_TwoComplement == true)
    {
        // Transfer Input Data To Temp Variable
        _iTwoComplement_Temp = iTwoComplement_Int;
        // Start Conversion From 2s Complement to Base To Integer - Check Sign MSb 
        if ((short)iTwoComplement_Int &  0b1000000000000000)
        {
            // Flip All Bits and Add One
            _iTwoComplement_Temp = ~_iTwoComplement_Temp + 1;
            _iTwoComplement_Temp= -_iTwoComplement_Temp;
        }
        else
        {
            // No Change if MSb = 0
            // _iTwoComplement_Temp = _iTwoComplement_Temp;
        }
        
        return _iTwoComplement_Temp;
    }
}


// *************************************//
// Define Function vCompass_SelfTest
// *************************************//
void vCompass_SelfTest()
{
    int _iSelfTest_AllAxisPassed=0;
    int _iSelfTest_XAxis_Passed=0;
    int _iSelfTest_YAxis_Passed=0;
    int _iSelfTest_ZAxis_Passed=0;
    int _iSelfTest_XAxis_Average=0;
    int _iSelfTest_YAxis_Average=0;
    int _iSelfTest_ZAxis_Average=0;
    int _iSelfTest_LimMax=0;
    int _iSelfTest_LimMin=0;
    int _iLoop_Counter=0;
    int _iSelfTest_Average_Count=8;
        
    // Set Registry A For Self Test Mode
    cCompass_ConfigRegA_Val = cCompass_SelfTest_ConfigAReg;
    // Verify Registry A Data
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg (Self Test): Composite Registry A Data : %#04x\n",cCompass_ConfigRegA_Val);}
    // Set Compass Data Output Average, Data Output Rate and Compass Measurement Mode 
    iI2C_Write=iCompass_I2CWriteBuff(cCompass_ConfigAReg,cCompass_ConfigRegA_Val);
    // Check For Error
    if (iI2C_Write<0)
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1){printf("Compass Error (Self Test): Failed to Set Device Output and Measurement Modes\n");}
    }
    else 
    {
        // Error Handling
        if (iDebug_Level >=Debug_Level_1){printf("Compass Msg (Self Test): Device Output and Measurement Modes Set\n");}
    }
    
    // Set Registry B Seft Test Gain Parameter 
    if (iError_No == Error_None)
    {
        // Write User Selected Gain To Compass
        iI2C_Write=iCompass_I2CWriteBuff(cCompass_ConfigBReg,cCompass_SetGain(prmCompass_SelfTest_GainValue[0]));
        // Check For Error
        if (iI2C_Write<0)
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Error (Self Test): Failed to Set Device Gain Value Range\n");}
        }
        else
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Msg (Self Test): Device Set to Requested Gain Value\n");}
        } 
    }
    
    // Set Compass Mode to Continuous for Self Test
    if (iError_No == Error_None)
    {           
        // Write User Selected Mode To Compass
        iI2C_Write=iCompass_I2CWriteBuff(cCompass_ModeReg,cCompass_Mode_ContMeasure);
        // Check For Error
        if (iI2C_Write<0)
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Error (Self Test): Failed to Set Device Operation Mode \n");}
        }
        else
        {
            // Error Handling
            if (iDebug_Level >=Debug_Level_1){printf("Compass Msg (Self Test): Device Set to Requested Operation Mode \n");}
        }   
    }
    
    // Clear Out Registry Data With Previous Gain Reading via Read Command 
    iI2C_Read=iCompass_I2CReadBuff();
    
    // Wait For New Data - Sleep 1 second
    sleep(1);
    
    // Take Multiple Readings
    for ( _iLoop_Counter = 1; _iLoop_Counter <=_iSelfTest_Average_Count ; _iLoop_Counter++ )
    {
        // Re-Read Registry
        iI2C_Read=iCompass_I2CReadBuff();
        
        // Get X-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_X_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_X_LSBReg];
        // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSB
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: X Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_X_MSBReg],cI2C_Buffer[cMagField_X_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        _iSelfTest_XAxis_Average += abs((short)iCompass_MagField_Temp);
        
        // Get Y-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_Y_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_Y_LSBReg];
        // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSB
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Y Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_Y_MSBReg],cI2C_Buffer[cMagField_Y_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        _iSelfTest_YAxis_Average +=abs((short)iCompass_MagField_Temp);
        
        // Get Z-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_Z_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_Z_LSBReg];
        // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSB
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Z Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_Z_MSBReg],cI2C_Buffer[cMagField_Z_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        _iSelfTest_ZAxis_Average +=abs((short)iCompass_MagField_Temp);
        
        // Time For Data Recapture
        sleep(0.67);
        // End Loop
    }
    
    // Set Compass Out of Self-Test Mode
    cCompass_ConfigRegA_Val = cCompass_SelfTest_Exit;
    // Verify Registry A Data
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg (Self Test): Composite Registry A Data : %#04x\n",cCompass_ConfigRegA_Val);}
    // Set Compass Data Output Average, Data Output Rate and Compass Measurement Mode 
    iI2C_Write=iCompass_I2CWriteBuff(cCompass_ConfigAReg,cCompass_ConfigRegA_Val);
 
    // Calculate Averages
    _iSelfTest_XAxis_Average=_iSelfTest_XAxis_Average/_iSelfTest_Average_Count;
    _iSelfTest_YAxis_Average=_iSelfTest_YAxis_Average/_iSelfTest_Average_Count;
    _iSelfTest_ZAxis_Average=_iSelfTest_ZAxis_Average/_iSelfTest_Average_Count;
    
    // Calculate Expected Min / Max for Selected Self Test Gain
    _iSelfTest_LimMax = cCompass_SelfTest_LimMax*cCompass_GetGainVal(cCompass_SetGain(prmCompass_SelfTest_GainValue[0]))/cCompass_GetGainVal(cCompass_Gain_390); 
    if (iDebug_Level >=Debug_Level_3){printf("Compass Msg (Self Text): Max Lim=%i * %i / %i\n",cCompass_SelfTest_LimMax,cCompass_GetGainVal(cCompass_SetGain(prmCompass_SelfTest_GainValue[0])),cCompass_GetGainVal(cCompass_Gain_390));}

    // Calculate Expected Min / Max for Selected Self Test Gain
    _iSelfTest_LimMin = cCompass_SelfTest_LimMin*cCompass_GetGainVal(cCompass_SetGain(prmCompass_SelfTest_GainValue[0]))/cCompass_GetGainVal(cCompass_Gain_390); 
    if (iDebug_Level >=Debug_Level_3){printf("Compass Msg (Self Text): Max Lim=%i * %i / %i\n",cCompass_SelfTest_LimMin,cCompass_GetGainVal(cCompass_SetGain(prmCompass_SelfTest_GainValue[0])),cCompass_GetGainVal(cCompass_Gain_390));}

    // Verify if Self Test Within Limit for X Axis
    if ((_iSelfTest_XAxis_Average>_iSelfTest_LimMin) && (_iSelfTest_XAxis_Average<_iSelfTest_LimMax))
    {
        _iSelfTest_XAxis_Passed=1;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) X-Axis Passed> Min: %i X-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_XAxis_Average,_iSelfTest_LimMax);}
    }
    else
    {
        _iSelfTest_XAxis_Passed=0;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) X-Axis Failed> Min: %i X-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_XAxis_Average,_iSelfTest_LimMax);}
        // Set Error
        iError_No=Error_Compass_No_SelfTest;
        // Set Error Level
        iError_Level = Error_Level_Critical;
    }

    // Verify if Self Test Within Limit for Y Axis
    if ((_iSelfTest_YAxis_Average>_iSelfTest_LimMin) && (_iSelfTest_YAxis_Average<_iSelfTest_LimMax))
    {
        _iSelfTest_YAxis_Passed=1;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) Y-Axis Passed> Min: %i Y-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_YAxis_Average,_iSelfTest_LimMax);}
  
    }
    else
    {
        _iSelfTest_YAxis_Passed=0;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) Y-Axis Failed> Min: %i Y-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_YAxis_Average,_iSelfTest_LimMax);}
        // Set Error
        iError_No=Error_Compass_No_SelfTest;
        // Set Error Level
        iError_Level = Error_Level_Critical;
    }    

    // Verify if Self Test Within Limit for Z Axis
    if ((_iSelfTest_ZAxis_Average>_iSelfTest_LimMin) && (_iSelfTest_ZAxis_Average<_iSelfTest_LimMax))
    {
        _iSelfTest_ZAxis_Passed=1;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) Z-Axis Passed> Min: %i Z-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_ZAxis_Average,_iSelfTest_LimMax);}
    }
    else
    {
        _iSelfTest_ZAxis_Passed=0;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg (Self Text) Z-Axis Failed> Min: %i Z-Value: %i Max: %i\n",_iSelfTest_LimMin,_iSelfTest_ZAxis_Average,_iSelfTest_LimMax);}
        // Set Error
        iError_No=Error_Compass_No_SelfTest;
        // Set Error Level
        iError_Level = Error_Level_Critical;
    } 
    
         
    // Output Info - Self Test Complete
    if (iError_No == Error_None)
    {
        // Ouput Program Flow
        if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg (Self Test): Program Flow State: Self Test Completed \nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    }
    else
    {
        // Ouput Program Flow
        if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg (Self Test): Program Flow State: Self Test Failed \nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    } 
}


// *************************************//
////// MAIN PROGRAM START ///////
// *************************************//


//sleep(1); // Sleep Time in Seconds

// Manually Set Parameter Data - Development
/*
prmI2C_DeviceNo[0]=1;
prmI2C_BusNo[0]=1;
prmCompass_DataOutRate[0]=7;
prmCompass_DataOutAvrg[0]=1;
prmCompass_MeasureMode[0]=1;
prmCompass_GainValue[0]=2;
prmCompass_OpMode[0]=1;        
prmCompass_DeclinationAng[0]=1;                         
prmDebug_InfoLevel[0]=7;                        
*/                          

// Read Parameter Data -Device Number
switch(prmI2C_DeviceNo[0])
{
    case  1:
        cCompass_I2C_Addr=cCompass_I2C_Addr1;
        break;
    default:
        cCompass_I2C_Addr=0x00;
        break;
}

// Read Parameter Data -Device Number - Check for Functions in Later Version
iDebug_Level = iSet_Debug_Level(prmDebug_InfoLevel[0]);

// Start Line
if (iDebug_Level >=Debug_Level_0){printf("**** Start of Compass S-Function Block Execution **** \n");}

// Check Parameters
if (iDebug_Level >=Debug_Level_1){printf("Compass Msg: Input Parameter Data: I2CBus: %#04x I2CAddress: %#04x\n",prmI2C_BusNo[0],cCompass_I2C_Addr);}

// Ouput Program Flow
if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 1: Parameters Initialized \nError No: %i Error Level: %i\n",iError_No, iError_Level);}

// Run Init Routines
if (xD[0]==0)
{
    //  Run Self Test
    if (prmCompass_SelfTest=true)
    {
       vCompass_SelfTest();
    } 
    
    // Initialize Compass
    if (iError_No == Error_None)
    {
        vCompass_Initialize();
    }
}

// Good To Go! Read Device Buffer     
if (iError_No == Error_None)
{
    // Read Compass Buffer
    iI2C_Read=iCompass_I2CReadBuff();
}

// Process Compass Data
if (iError_No == Error_None)
{
    // Read Data Status Registry 
    cI2C_StatReg_Temp=cI2C_Buffer[cCompass_StatusReg];
    if (iDebug_Level >=Debug_Level_2){printf("Compass Diagnostics: STATUS_REG 0x00: %#04x \n",cI2C_Buffer[cCompass_StatusReg]);}
        
    // Check For Overwritten Data
    if (cI2C_StatReg_Temp &  0b00000001)
    {
        iI2C_STATUS_REG_DATARDY=1; 
    }
    // Output
    if (iDebug_Level >=Debug_Level_2) {printf("Compass Msg: Data Available: %i \n",iI2C_STATUS_REG_DATARDY);}
            
    // Read Compass Data If Data Ready  
    if (iI2C_STATUS_REG_DATARDY==1)
    {
        // Extract Raw Data and Calculate Heading
        
        // Get X-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_X_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_X_LSBReg];
        // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSB
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: X Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_X_MSBReg],cI2C_Buffer[cMagField_X_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        iCompass_MagField_Temp=(short)iCompass_MagField_Temp;
        //
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: X Field> MSB: %#04x ; LSB: %#04x Count: %#06x Short Value: %i\n",cI2C_Buffer[cMagField_X_MSBReg],cI2C_Buffer[cMagField_X_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 1      
        dCompass_MagField_Temp = (double)iCompass_MagField_Temp/cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0]));
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 2
        dCompass_MagField_Temp = (double)iCompass_Gauss_uTesla_Conv*dCompass_MagField_Temp;       
       // Set Output!
        outMagField_HX[0]=dCompass_MagField_Temp;
        // Check Calculation
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Calc: ConvFact*Field/Gain = %i*%i/%i=%.2f\n",iCompass_Gauss_uTesla_Conv,iCompass_MagField_Temp,cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0])),outMagField_HX[0]);}       
        
        // Get Y-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_Y_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_Y_LSBReg];
         // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSBcom
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Y Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_Y_MSBReg],cI2C_Buffer[cMagField_Y_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        iCompass_MagField_Temp = (short)iCompass_MagField_Temp;
        // 
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Y Field> MSB: %#04x ; LSB: %#04x Count: %#06x Short Value: %i\n",cI2C_Buffer[cMagField_Y_MSBReg],cI2C_Buffer[cMagField_Y_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 1      
        dCompass_MagField_Temp = (double)iCompass_MagField_Temp/cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0]));
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 2
        dCompass_MagField_Temp = (double)iCompass_Gauss_uTesla_Conv*dCompass_MagField_Temp; 
        // Set Output!
        outMagField_HY[0]=dCompass_MagField_Temp;
        // Check Calculation
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Calc: ConvFact*Field/Gain = %i*%i/%i=%.2f\n",iCompass_Gauss_uTesla_Conv,iCompass_MagField_Temp,cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0])),outMagField_HY[0]);}
        
        // Get Z-Axis Component of Magnetic Field
        iCompass_MagField_Temp=0;
        dCompass_MagField_Temp=0.0f;
        iCompass_MagField_Temp = cI2C_Buffer[cMagField_Z_MSBReg];
        iCompass_MagField_Temp = (iCompass_MagField_Temp<<8) | cI2C_Buffer[cMagField_Z_LSBReg];
         // Check For Two's Complement Conversion
        iCompass_MagField_Temp=iCompass_TwoComplement(iOpt_TwoComplement,iCompass_MagField_Temp);
        // Output MBS and LSB
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Z Field> MSB: %#04x ; LSB: %#04x Count: %#06x Value: %i\n",cI2C_Buffer[cMagField_Z_MSBReg],cI2C_Buffer[cMagField_Z_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
        // Convert Int (Int32) to Int16
        iCompass_MagField_Temp = (short)iCompass_MagField_Temp;
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Z Field> MSB: %#04x ; LSB: %#04x Count: %#06x Short Value: %i\n",cI2C_Buffer[cMagField_Z_MSBReg],cI2C_Buffer[cMagField_Z_LSBReg],iCompass_MagField_Temp,iCompass_MagField_Temp);}
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 1      
        dCompass_MagField_Temp = (double)iCompass_MagField_Temp/cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0]));
         // Convert Int16 to Double - Output Data in Micro Teslas - Calc Op 2
        dCompass_MagField_Temp = (double)iCompass_Gauss_uTesla_Conv*dCompass_MagField_Temp;       
        // Set Output!
        outMagField_HZ[0]=dCompass_MagField_Temp;
        // Check Calculation
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Calc: ConvFact*Field/Gain = %i*%i/%i=%.2f\n",iCompass_Gauss_uTesla_Conv,iCompass_MagField_Temp,cCompass_GetGainVal(cCompass_SetGain(prmCompass_GainValue[0])),outMagField_HZ[0]);}

        // Calculate Heading (Non Compensated for Roll/Pitch) wrt Magnetic North
        outMagField_Heading[0]=atan2(outMagField_HY[0],outMagField_HX[0])*180.0f/M_PI;
        
        // Output Heading Depending on Mode Selected
        switch(prmCompass_HeadingMode[0])
        {
            case  1:
                 // Calculate Heading (Non Compensated for Roll/Pitch) wrt Magnetic North
                 // Do Nothing;
                break;
            case  2:
                // Calculate Heading (Non Compensated for Roll/Pitch) wrt True North
                outMagField_Heading[0] = outMagField_Heading[0] + (double)prmCompass_DeclinationAng[0];
                break;
            default:
                // Do Nothing;
                break;
        }
 
        // Adjust for Any Interference/Unexplained Offset Error
        outMagField_Heading[0] += prmCompass_HeadingOffset[0];
        
        // Check For Negative Heading
        if (outMagField_Heading[0]<0.0f)
        {
            outMagField_Heading[0] = outMagField_Heading[0]+360.0f;
        }
        
        // Calcualte Magnetic Field Strength (Micro Teslas) - Note: Montreal = 54.1267
        outMagField_HE[0] = sqrt(powf(outMagField_HX[0],2.0f)+powf(outMagField_HY[0],2.0f)+powf(outMagField_HZ[0],2.0f));      
        
        // Ouput Program Flow
        if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 5: Device Data Read\nError No: %i Error Level: %i\n",iError_No, iError_Level);}
        
        // Print Output - Magnetic Fields
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Magnetic Field (uTelsas) X: %.1f Y: %.1f Z: %.1f Magnitude: %.1f\n",outMagField_HX[0],outMagField_HY[0],outMagField_HZ[0],outMagField_HE[0]);}
        // Print Output - Heading
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: Heading (degrees) : %f \n",outMagField_Heading[0]);}                     
    }
    else
    {
        if (iDebug_Level >=Debug_Level_0){printf("Compass Msg: No New Data Ready\n");}
        // Update Data Skip Count
        iLoop_DataNotReady_Counter=xD[1];
        iLoop_DataNotReady_Counter +=1;   
    }
    
    // Output Data Skip Count
    if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Data Skip Count: %i\n",iLoop_DataNotReady_Counter);}
}
// Ouput Program Flow
if (iDebug_Level >=Debug_Level_3) {printf("Compass Msg: Program Flow State 6: Loop Step Complete\nError No: %i Error Level: %i\n",iError_No, iError_Level);}

// Check For Critical Errors and Stop Simulation  
if ((iError_No!=0)&&(iError_Level==Error_Level_Critical))
{ 
    // Stop Simulation If Critical Error
    if (iDebug_Level >=Debug_Level_0) {printf("Compass Msg: Critical Error Detected; Simulation Stopping! \nError No: %i Error Level: %i\n",iError_No, iError_Level);}
    
    // Output Error Message:
    if (iDebug_Level >=Debug_Level_0) {printf("Compass Error Details: %s",sCompass_ErrMessage(iError_No));}
    
    // Stop Simulation
    outSimStop[0]=true;
}
else
{
    // Carry on
    outSimStop[0]=false;
}

// Print Gap
if (iDebug_Level >=Debug_Level_0){printf("\n");}
// uint8(prmI2C_DeviceNo),uint8(prmI2C_BusNo),uint8(prmCompass_DataOutAvrg),uint8(prmCompass_DataOutRate),uint8(prmCompass_MeasureMode),uint8(prmCompass_GainValue),uint8(prmCompass_OpMode),uint8(prmCompass_HeadingMode),real(prmCompass_HeadingOffset),real(prmCompass_DeclinationAng),boolean(prmCompass_SelfTest),uint8(prmCompass_SelfTest_GainValue),uint8(prmDebug_InfoLevel)
// uint8(BBB_I2CDeviceNo),uint8(BBB_I2CBusNo),uint8(BBB_Compass_DataOutAvrg),uint8(BBB_Compass_DataOutRate),uint8(BBB_Compass_MeasureMode),uint8(BBB_Compass_GainValue),uint8(BBB_Compass_OpMode),uint8(BBB_Compass_HeadingMode),real(BBB_Compass_HeadingOffset),real(BBB_Compass_DeclinationAng),boolean(BBB_Compass_SelfTest),uint8(BBB_Compass_SelfTest_GainValue),uint8(BBB_DebugInfoLevel)
// uint8(BBB_I2CDeviceNo),uint8(BBB_I2CBusNo),uint8(BBB_Compass_DataOutAvrg),uint8(BBB_Compass_DataOutRate),uint8(BBB_Compass_MeasureMode),uint8(BBB_Compass_GainValue),uint8(BBB_Compass_OpMode),uint8(BBB_Compass_HeadingMode),double(BBB_Compass_HeadingOffset),double(BBB_Compass_DeclinationAng),boolean(BBB_Compass_SelfTest),uint8(BBB_Compass_SelfTest_GainValue),uint8(BBB_DebugInfoLevel)
# else
# endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}

/*
  * Updates function
  *
  */
void BBB_Driver_Compass_HMC5883L_Update_wrapper(const real_T *outMagField_HX,
                          const real_T *outMagField_HY,
                          const real_T *outMagField_HZ,
                          const real_T *outMagField_HE,
                          const real_T *outMagField_Heading,
                          const real_T *outSimStop ,
                          real_T *xD, 
                          const uint8_T  *prmI2C_DeviceNo,  const int_T  p_width0,
                          const uint8_T  *prmI2C_BusNo,  const int_T  p_width1,
                          const uint8_T  *prmCompass_DataOutAvrg,  const int_T  p_width2,
                          const uint8_T  *prmCompass_DataOutRate,  const int_T  p_width3,
                          const uint8_T  *prmCompass_MeasureMode,  const int_T  p_width4,
                          const uint8_T  *prmCompass_GainValue,  const int_T  p_width5,
                          const uint8_T  *prmCompass_OpMode,  const int_T  p_width6,
                          const uint8_T  *prmCompass_HeadingMode,  const int_T  p_width7,
                          const real_T  *prmCompass_HeadingOffset,  const int_T  p_width8,
                          const real_T  *prmCompass_DeclinationAng,  const int_T  p_width9,
                          const boolean_T  *prmCompass_SelfTest,  const int_T  p_width10,
                          const uint8_T  *prmCompass_SelfTest_GainValue,  const int_T  p_width11,
                           const uint8_T *prmDebug_InfoLevel, const int_T  p_width12)
{
  /* %%%-SFUNWIZ_wrapper_Update_Changes_BEGIN --- EDIT HERE TO _END */
// Run Only on Target - BeagleBoneBlack */
# ifndef MATLAB_MEX_FILE

// Update Init Bit
if (xD[0]==0)
{
    // Set Init Complete 
    xD[0]=1; 
    
}

// Update Register Locked / No New Data Counter
xD[1]=iLoop_DataNotReady_Counter;

# else

// Do Nothing


# endif
/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
}
