/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Mon Sep 22 17:03:46 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

typedef enum 
{
       	Debug_None,
	Debug_Level_0, // Basic Debug Info Output
        Debug_Level_1, // + Critical Info Only
	Debug_Level_2, // + Diagnostics Info
	Debug_Level_3, // + Program Flow Info
	Debug_Level_4, // + Registry Data
	Debug_Level_5  // + TBD 
}eDebugLevel;


// Initialize Error
// eError_No iError_No = Error_None;

// Define Error Severity Levels
typedef enum
{
    Error_Level_OK=0,
    Error_Level_Critical, // (Stop Simulation)
    Error_Level_Warning
}eError_Level;
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void BBB_AHRS_IMU_v2_Outputs_wrapper(const real_T *inGyro_w_x,
                          const real_T *inGyro_w_y,
                          const real_T *inGyro_w_z,
                          const real_T *inAccel_a_x,
                          const real_T *inAccel_a_y,
                          const real_T *inAccel_a_z,
                          real_T *outQuat_q_1,
                          real_T *outQuat_q_2,
                          real_T *outQuat_q_3,
                          real_T *outQuat_q_4,
                          boolean_T *outStopSim,
                          const real_T  *xD)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
# ifndef MATLAB_MEX_FILE

// Initialize Estimated Quaternions
double dEst_q_1=0.0f;
double dEst_q_2=0.0f;
double dEst_q_3=0.0f;        
double dEst_q_4=0.0f;
double dEst_q_Norm=0.0f;

double dEst_S_E_q_1_dot=0;
double dEst_S_E_q_2_dot=0;
double dEst_S_E_q_3_dot=0;
double dEst_S_E_q_4_dot=0;

// Declare and Initialize Gyro and Accel Data Temp Variables
double dGyro_w_x=0.0f,dGyro_w_y=0.0f,dGyro_w_z=0.0f;
double dAccel_a_x=0.0f,dAccel_a_y=0.0f,dAccel_a_z=0.0f;
double dAccel_Norm=0.0f,dAccel_a_Norm_x=0.0f,dAccel_a_Norm_y=0.0f,dAccel_a_Norm_z=0.0f;

// Declare and Initialize Quaternion Angular Rate Variables
double dS_E_q_w_1_dot=0;
double dS_E_q_w_2_dot=0;
double dS_E_q_w_3_dot=0;
double dS_E_q_w_4_dot=0;

// Declare Objective Function Data
double dObjective_f_11=0,dObjective_f_21=0,dObjective_f_31=0;
double dObjective_J_11=0,dObjective_J_12=0,dObjective_J_13=0,dObjective_J_14=0;
double dObjective_J_21=0,dObjective_J_22=0,dObjective_J_23=0,dObjective_J_24=0;
double dObjective_J_31=0,dObjective_J_32=0,dObjective_J_33=0,dObjective_J_34=0;
double dObjective_J_41=0,dObjective_J_42=0,dObjective_J_43=0,dObjective_J_44=0;
double dObjective_Grad_f_11=0.0f,dObjective_Grad_f_21=0.0f,dObjective_Grad_f_31=0.0f,dObjective_Grad_f_41=0.0f;
double dObjective_Grad_f_Norm=0.0f;

// Define Constants
#define dSample_Period_Delta_t 0.01f
#define dGain_Beta 0.1f // Divergence Rate of S_E_q_w
#define dGain_Alpha 0.1f // Convergence Reate of S_E_q_w_Grad

// Define Error Number
typedef enum 
{
    Error_None=0,
    Error_No_SYSFSOpen,
    Error_No_SYSFSRead,
    Error_No_SYSFSWrite,
    Error_No_ParamOutofRange
}eError_No;

// Initialize Error
eError_No iError_No = Error_None;

// Initialize Debug Level
eDebugLevel iDebug_Level = Debug_None;


/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
// Main Program Start 
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/

// Read Input Data To Local Variables
dGyro_w_x=inGyro_w_x[0];
dGyro_w_y=inGyro_w_y[0];
dGyro_w_z=inGyro_w_z[0];
dAccel_a_x=inAccel_a_x[0];
dAccel_a_y=inAccel_a_y[0];
dAccel_a_z=inAccel_a_z[0];


// Initialize Quaternion Data During First Scan
if (xD[0]==0)
{
   // Set Initial Quaternion Values - Senor Frame Aligned with Earth Frame
    dEst_q_1=1.0f; 
    dEst_q_2=0.0f;     
    dEst_q_3=0.0f; 
    dEst_q_4=0.0f;
    // Output Estimated Quaternion Data
   if (iDebug_Level >=Debug_Level_3) { printf("Quaternion Data Init> Q1: %.2f Q2: %.2f Q3: %.2f Q4: %.2f\n",dEst_q_1,dEst_q_2,dEst_q_3,dEst_q_4);}
}
else if (xD[0]==1)
{
    // Populate Quaternion Local Variables With Saved Persistent Data From 
    // Previous Timestep (t-1)
    dEst_q_1=xD[1];
    dEst_q_2=xD[2];
    dEst_q_3=xD[3];
    dEst_q_4=xD[4];
    // Output Estimated Quaternion Data 
    if (iDebug_Level >=Debug_Level_3) { printf("Quaternion Data Update> Q1: %.2f Q2: %.2f Q3: %.2f Q4: %.2f\n",dEst_q_1,dEst_q_2,dEst_q_3,dEst_q_4);}

}

// Output Estimated Quaternion Data 
//if (iDebug_Level >=Debug_Level_3) { printf("Quaternion Data Update> Q1: %.2f Q2: %.2f Q3: %.2f Q4: %.2f %s\n",dEst_q_1,dEst_q_2,dEst_q_3,dEst_q_4);}

   
// Read Input Data into Temporary Varialbes

/*************************************************************************/
// Step 1: Filter > Get Attitude from Angular Rate (Gyros)
/*************************************************************************/
// Step 1.1: > Calculate Quaternion Derivative for Rate of Change of 
// Orientation of Earth Frame Relative To Sensor Frame
dS_E_q_w_1_dot=0.5f*(-dEst_q_2*dGyro_w_x - dEst_q_3*dGyro_w_y - dEst_q_4*dGyro_w_z);
dS_E_q_w_2_dot=0.5f*( dEst_q_1*dGyro_w_x + dEst_q_3*dGyro_w_z - dEst_q_4*dGyro_w_y);
dS_E_q_w_3_dot=0.5f*( dEst_q_1*dGyro_w_y - dEst_q_2*dGyro_w_z + dEst_q_4*dGyro_w_x);
dS_E_q_w_4_dot=0.5f*(-dEst_q_1*dGyro_w_z + dEst_q_2*dGyro_w_y - dEst_q_3*dGyro_w_x);

// Step 1.2: > Carry out Numerical Integration of Quaternion Derivative
// Note: Step 1.2 Not required as "alpha" constant - Constant used to
// augment "mu" (stepsize) - is assumed >>> 0. 


/*************************************************************************/
// Step 2: Calculate Gradient of the Objective Function "f"
// Which Descibes The Optimization Problem. 
// Note: The optimization problem aims to minimize the difference between
// a given reference direction of the field (gravity) in the earth field 
// and the measured direction of the field in sensor frame via a rotational 
// transform operation.
/*************************************************************************/

// Step 2.1 > Normalize Accelerometer Measurements
dAccel_Norm = sqrt(dAccel_a_x*dAccel_a_x+dAccel_a_y*dAccel_a_y+dAccel_a_z*dAccel_a_z);
dAccel_a_Norm_x=dAccel_a_x/dAccel_Norm;
dAccel_a_Norm_y=dAccel_a_y/dAccel_Norm;
dAccel_a_Norm_z=dAccel_a_z/dAccel_Norm;

// Step 2.2 > Calculate Objective Function Array "f"
dObjective_f_11=(2.0f*(dEst_q_2*dEst_q_4-dEst_q_1*dEst_q_3)-dAccel_a_Norm_x);
dObjective_f_21=(2.0f*(dEst_q_1*dEst_q_2+dEst_q_3*dEst_q_4)-dAccel_a_Norm_y);
dObjective_f_31=(2.0f*(0.5f-dEst_q_2*dEst_q_2-dEst_q_3*dEst_q_3)-dAccel_a_Norm_z);

// Step 2.3 > Calculate Jacobian Matrix of Objective Function
dObjective_J_11=-2.0f*dEst_q_3;
dObjective_J_12= 2.0f*dEst_q_4;
dObjective_J_13=-2.0f*dEst_q_1;
dObjective_J_14= 2.0f*dEst_q_2;
dObjective_J_21= 2.0f*dEst_q_2;
dObjective_J_22= 2.0f*dEst_q_1;
dObjective_J_23= 2.0f*dEst_q_4;
dObjective_J_24= 2.0f*dEst_q_3;
dObjective_J_31= 0.0f;
dObjective_J_32=-4.0f*dEst_q_2;
dObjective_J_33=-4.0f*dEst_q_3;
dObjective_J_34= 0.0f;

// Step 2.3 > Calculate Gradient of Objective Function
dObjective_Grad_f_11=dObjective_J_11*dObjective_f_11 + dObjective_J_21*dObjective_f_21 + dObjective_J_31*dObjective_f_31;
dObjective_Grad_f_21=dObjective_J_12*dObjective_f_11 + dObjective_J_22*dObjective_f_21 + dObjective_J_32*dObjective_f_31;
dObjective_Grad_f_31=dObjective_J_13*dObjective_f_11 + dObjective_J_23*dObjective_f_21 + dObjective_J_33*dObjective_f_31;
dObjective_Grad_f_41=dObjective_J_14*dObjective_f_11 + dObjective_J_24*dObjective_f_21 + dObjective_J_34*dObjective_f_31;

// Step 2.4 > Calculate Gradient Norm
dObjective_Grad_f_Norm=sqrt(dObjective_Grad_f_11*dObjective_Grad_f_11+dObjective_Grad_f_21*dObjective_Grad_f_21+dObjective_Grad_f_31*dObjective_Grad_f_31+dObjective_Grad_f_41*dObjective_Grad_f_41);

/*************************************************************************/
// Step 3: Fusion of Accel and Gyro Sensor Data To Generate Increment Estimate
/*************************************************************************/
dEst_S_E_q_1_dot=(dS_E_q_w_1_dot - dGain_Beta*dObjective_Grad_f_11/dObjective_Grad_f_Norm);
dEst_S_E_q_2_dot=(dS_E_q_w_2_dot - dGain_Beta*dObjective_Grad_f_21/dObjective_Grad_f_Norm);
dEst_S_E_q_3_dot=(dS_E_q_w_3_dot - dGain_Beta*dObjective_Grad_f_31/dObjective_Grad_f_Norm);
dEst_S_E_q_4_dot=(dS_E_q_w_4_dot - dGain_Beta*dObjective_Grad_f_41/dObjective_Grad_f_Norm);

/*************************************************************************/
// Step 4: Numerical Integration of Quaternion Rate Data
/*************************************************************************/

// Step 4.1 > Carry Out Numerical Integration 

dEst_q_1=dEst_q_1+dEst_S_E_q_1_dot*dSample_Period_Delta_t;
dEst_q_2=dEst_q_2+dEst_S_E_q_2_dot*dSample_Period_Delta_t;
dEst_q_3=dEst_q_3+dEst_S_E_q_3_dot*dSample_Period_Delta_t;
dEst_q_4=dEst_q_4+dEst_S_E_q_4_dot*dSample_Period_Delta_t;

// Step 4.2 > Calculate Quaternion Norm
dEst_q_Norm = sqrt(dEst_q_1*dEst_q_1 + dEst_q_2*dEst_q_2 +dEst_q_3*dEst_q_3 +dEst_q_4*dEst_q_4);

/*************************************************************************/
// Step 5: Normalize and Output Quaternion Data
/*************************************************************************/
dEst_q_1 = dEst_q_1/dEst_q_Norm;
dEst_q_2 = dEst_q_2/dEst_q_Norm;
dEst_q_3 = dEst_q_3/dEst_q_Norm;
dEst_q_4 = dEst_q_4/dEst_q_Norm;

/*************************************************************************/
// Step 6: Switch Base Reference Frame If Needed
// Note: Represent quarternions as sensor attitude relative to fixed earth
// i.e d_Est_E_S_q_X where X = 1,2,3,4
/*************************************************************************/
/*
outQuat_q_1[0]=dEst_q_1;
outQuat_q_2[0]=-dEst_q_2;
outQuat_q_3[0]=-dEst_q_3;
outQuat_q_4[0]=-dEst_q_4;
*/
outQuat_q_1[0]=dEst_q_1;
outQuat_q_2[0]=dEst_q_2;
outQuat_q_3[0]=dEst_q_3;
outQuat_q_4[0]=dEst_q_4;

// Output Quaternion Data
if (iDebug_Level >=Debug_Level_1) { printf("Quaternion Data> Q1: %.2f Q2: %.2f Q3: %.2f Q4: %.2f\n",outQuat_q_1[0],outQuat_q_2[0],outQuat_q_3[0],outQuat_q_4[0]);}


# endif
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}

/*
  * Updates function
  *
  */
void BBB_AHRS_IMU_v2_Update_wrapper(const real_T *inGyro_w_x,
                          const real_T *inGyro_w_y,
                          const real_T *inGyro_w_z,
                          const real_T *inAccel_a_x,
                          const real_T *inAccel_a_y,
                          const real_T *inAccel_a_z,
                          const real_T *outQuat_q_1,
                          const real_T *outQuat_q_2,
                          const real_T *outQuat_q_3,
                          const real_T *outQuat_q_4,
                          const boolean_T *outStopSim,
                          real_T *xD)
{
  /* %%%-SFUNWIZ_wrapper_Update_Changes_BEGIN --- EDIT HERE TO _END */
/* Only Execute On Target*/
# ifndef MATLAB_MEX_FILE

// Recall Discrete State Data
// xD[0] = First Scan
// xD[1] = Estimated Quaternion dEst_q_1
// xD[2] = Estimated Quaternion dEst_q_2
// xD[3] = Estimated Quaternion dEst_q_3
// xD[4] = Estimated Quaternion dEst_q_4

if (xD[0]==0)
{
    // Initialize Quaternions
    
    // Set First Scan Bit
    xD[0]=1;
}

// Update Persistent Quaternion Data
xD[1]=outQuat_q_1[0];
xD[2]=outQuat_q_2[0];
xD[3]=outQuat_q_3[0];
xD[4]=outQuat_q_4[0];


# endif
/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
}
